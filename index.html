<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Three.js Heightmap Pointcloud (Masked)</title>
  <style>
    html, body { 
      margin: 0; 
      height: 100%; 
      background: #0e0f13; 
      color: #e6e6e6; 
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }
    #app-container {
      display: flex;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #canvas-container canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    canvas.drop-target {
      outline: 1px solid transparent;
      transition: outline-color 0.2s ease;
    }
    canvas.drop-target.drag-over {
      outline: 2px dashed rgba(155, 187, 221, 0.85);
    }
    #panel-container {
      width: 280px;
      min-width: 280px;
      height: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      background: rgba(20, 22, 28, 0.95);
      border-left: 1px solid rgba(255, 255, 255, 0.08);
      scrollbar-width: thin;
      scrollbar-color: #444 #1a1c22;
    }
    #panel-container::-webkit-scrollbar {
      width: 8px;
    }
    #panel-container::-webkit-scrollbar-track {
      background: #1a1c22;
    }
    #panel-container::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }
    #panel-container::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    /* Override Tweakpane container styles */
    #panel-container .tp-dfwv {
      width: 100% !important;
      position: relative !important;
      right: auto !important;
      top: auto !important;
    }
    #overlayInfo {
      position: absolute;
      bottom: 12px;
      left: 12px;
      font-size: 12px;
      color: #b0b5bd;
      background: rgba(20, 22, 28, 0.75);
      padding: 6px 10px;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
      z-index: 10;
    }
    #overlayInfo a {
      color: #9bd;
    }
    a, a:visited { color: #9bd; text-decoration: none; }
    a:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <div id="app-container">
    <div id="canvas-container">
      <div id="overlayInfo">Drag a heightmap onto the canvas to replace. Project by <a href="https://x.com/taylor_sntx" target="_blank" rel="noopener">Taylor</a></div>
    </div>
    <div id="panel-container"></div>
  </div>
  <input id="heightmapFile" type="file" accept="image/png,image/jpeg,image/webp" style="display:none;">

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/",
        "tweakpane": "https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { Pane } from 'tweakpane';
    const DEFAULT_HEIGHTMAP_URL = 'assets/heightmap_512x512.png';
    // Track mouse for hover effects (canvasContainer defined after scene setup)
    window.__mouseNdc = new THREE.Vector2(-2, -2);
    

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0e0f13);

    const canvasContainer = document.getElementById('canvas-container');
    const camera = new THREE.PerspectiveCamera(55, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
    camera.position.set(0, 10, 18);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
    canvasContainer.appendChild(renderer.domElement);
    renderer.domElement.classList.add('drop-target');

    // Mouse tracking for hover effects
    canvasContainer.addEventListener('mousemove', (e) => {
      const rect = canvasContainer.getBoundingClientRect();
      window.__mouseNdc.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      window.__mouseNdc.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    });
    canvasContainer.addEventListener('mouseleave', () => {
      window.__mouseNdc.set(-2, -2);
    });

    // Mouse scroll for camera distance control
    // Min/max limits for each camera mode
    const cameraLimits = {
      chase: { min: 0.5, max: 8, param: 'chaseCamDistance', step: 0.2 },
      topdown: { min: 3, max: 20, param: 'topCamHeight', step: 0.5 },
      isometric: { min: 2, max: 15, param: 'isoCamDistance', step: 0.3 }
    };
    
    canvasContainer.addEventListener('wheel', (e) => {
      e.preventDefault();
      const mode = params?.cameraMode;
      if (!mode || !cameraLimits[mode]) return;
      
      const limits = cameraLimits[mode];
      const direction = e.deltaY > 0 ? 1 : -1; // scroll down = zoom out (increase distance)
      const newValue = params[limits.param] + direction * limits.step;
      params[limits.param] = Math.max(limits.min, Math.min(limits.max, newValue));
      
      // Update pane to reflect change
      if (typeof pane !== 'undefined' && pane.refresh) {
        pane.refresh();
      }
    }, { passive: false });

    // Right-click drag for camera orbit around airplane
    const cameraOrbit = {
      isDragging: false,
      lastX: 0,
      lastY: 0,
      azimuth: 0,       // horizontal angle (radians)
      elevation: 0,     // vertical angle offset (radians) - for pitch adjustment
      sensitivity: 0.005,
      // Min/max elevation for each mode (radians)
      elevationLimits: {
        chase: { min: -0.3, max: 0.5 },
        topdown: { min: -0.2, max: 0.2 },  // limited for top-down
        isometric: { min: -0.4, max: 0.6 }
      }
    };

    canvasContainer.addEventListener('mousedown', (e) => {
      if (e.button === 2) { // Right click
        cameraOrbit.isDragging = true;
        cameraOrbit.lastX = e.clientX;
        cameraOrbit.lastY = e.clientY;
        e.preventDefault();
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (!cameraOrbit.isDragging) return;
      
      const deltaX = e.clientX - cameraOrbit.lastX;
      const deltaY = e.clientY - cameraOrbit.lastY;
      cameraOrbit.lastX = e.clientX;
      cameraOrbit.lastY = e.clientY;
      
      // Update azimuth (horizontal orbit)
      cameraOrbit.azimuth -= deltaX * cameraOrbit.sensitivity;
      
      // Update elevation (vertical angle) with limits based on mode
      const mode = params?.cameraMode || 'chase';
      const limits = cameraOrbit.elevationLimits[mode] || { min: -0.5, max: 0.5 };
      cameraOrbit.elevation = Math.max(limits.min, Math.min(limits.max, 
        cameraOrbit.elevation + deltaY * cameraOrbit.sensitivity
      ));
    });

    window.addEventListener('mouseup', (e) => {
      if (e.button === 2) {
        cameraOrbit.isDragging = false;
      }
    });

    // Prevent context menu on right-click
    canvasContainer.addEventListener('contextmenu', (e) => {
      e.preventDefault();
    });

    const clock = new THREE.Clock();
    const initialCamPos = new THREE.Vector3().copy(camera.position);
    const initialCamQuat = new THREE.Quaternion().copy(camera.quaternion);
    let defaultCamPos;
    let defaultCamQuat;
    

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.45);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    // Ground grid for scale reference
    const grid = new THREE.GridHelper(200, 200, 0x33353a, 0x1e2026);
    grid.material.opacity = 0.35;
    grid.material.transparent = true;
    grid.material.depthWrite = false;
    grid.material.depthTest = false;
    grid.visible = false;
    scene.add(grid);

    // Plane setup
    const initialSize = 12; // default tile size
    let segments = 256; // will be controlled by UI (subdivisions)

    let plane = null; // unused after tiling in pointcloud mode
    const pointMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uMap: { value: null },
        uScale: { value: 2.8 },
        uBias: { value: -2.8 * 0.5 },
        uColor: { value: new THREE.Color(0x8a8f9a) },
        uPointSize: { value: 2.0 },
        uTime: { value: 0.0 },
        uJitter: { value: 0.02 },
        uMaskCenter: { value: new THREE.Vector2(0.0, 0.0) },
        uMaskRadius: { value: 4.0 },
        uMaskFeather: { value: 0.6 },
        uHoverCenter: { value: new THREE.Vector2(9999.0, 9999.0) },
        uHoverRadius: { value: 1.6 },
        uHoverStrength: { value: 0.8 },
        uHoverSnap: { value: 2.0 },
        uHoverColor: { value: new THREE.Color(0xffcc55) },
        uHoverEnabled: { value: 1.0 },
        // Airplane hover highlight
        uAirplanePos: { value: new THREE.Vector3(9999, 9999, 9999) },
        uAirplaneHoverEnabled: { value: 0.0 },
        uAirplaneHoverRadius: { value: 2.0 },
        // Radar pulse
        uRadarActive: { value: 0.0 },
        uRadarOrigin: { value: new THREE.Vector3(0, 0, 0) },
        uRadarRadius: { value: 0.0 },
        uRadarRingWidth: { value: 0.6 },
        uRadarFade: { value: 1.0 },
        // Radar rain animation
        uRadarRainHeight: { value: 41.0 },     // How high particles start above final position
        uRadarRainDuration: { value: 0.35 },   // How long the fall animation takes (seconds)
        uRadarTime: { value: 0.0 },            // Current time since radar started
        uRadarExpandSpeed: { value: 9.72 },    // Units per second for ring expansion
        uRadarShowRing: { value: 0.0 },        // Whether to show the colored ring effect
        uRadarRingFeather: { value: 0.1 },     // Softness of the ring edges
        // Rain and ring colors
        uRainColor: { value: new THREE.Color(0xbff4ff) },           // Color of falling particles
        uRadarRingColorLow: { value: new THREE.Color(0x00ccff) },   // Ring color for valleys
        uRadarRingColorMid: { value: new THREE.Color(0x00ff80) },   // Ring color for mid
        uRadarRingColorHigh: { value: new THREE.Color(0xffee33) },  // Ring color for peaks
        uRainColorFadeDuration: { value: 1.0 },                      // Time to crossfade from rain to ring color
        // Rain particle shape
        uRainParticleWidth: { value: 0.08 },
        uRainParticleHeight: { value: 0.45 },
        uRainParticleScale: { value: 25.0 },
        uAirplaneColorFar: { value: new THREE.Color(0x00ffaa) },  // cyan-green when high/safe
        uAirplaneColorClose: { value: new THREE.Color(0xff0000) }, // pure red when low/danger
        // Fog uniforms expected by renderer when material.fog === true
        fogColor: { value: new THREE.Color(0x0e0f13) },
        fogNear: { value: 1 },
        fogFar: { value: 1000 },
        fogDensity: { value: 0.00025 }
      },
      transparent: true,
      depthWrite: true,
      blending: THREE.NormalBlending,
      fog: true,
      vertexShader: `
        #include <uv_pars_vertex>
        varying float vMaskAlpha;
        varying float vHoverMix;
        varying float vAirplaneMix;
        varying float vAirplaneProximity;
        varying float vRadarMix;
        varying float vRadarHeight;
        varying float vRadarRainOpacity;
        varying float vRainColorBlend;
        #include <fog_pars_vertex>
        uniform sampler2D uMap;
        uniform float uScale;
        uniform float uBias;
        uniform float uPointSize;
        uniform float uTime;
        uniform float uJitter;
        uniform vec2 uMaskCenter;
        uniform float uMaskRadius;
        uniform float uMaskFeather;
        uniform vec2 uHoverCenter;
        uniform float uHoverRadius;
        uniform float uHoverStrength;
        uniform float uHoverSnap;
        uniform float uHoverEnabled;
        uniform vec3 uAirplanePos;
        uniform float uAirplaneHoverEnabled;
        uniform float uAirplaneHoverRadius;
        // Radar pulse
        uniform float uRadarActive;
        uniform vec3 uRadarOrigin;
        uniform float uRadarRadius;
        uniform float uRadarRingWidth;
        uniform float uRadarFade;
        uniform float uRadarRainHeight;
        uniform float uRadarRainDuration;
        uniform float uRadarTime;
        uniform float uRadarExpandSpeed;
        uniform float uRadarRingFeather;
        uniform float uRainColorFadeDuration;
        uniform float uRainParticleScale;
        // hash-based 2D noise -> scalar in [-1,1]
        float hash(vec2 p){
          return -1.0 + 2.0 * fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
        }
        void main() {
          #include <uv_vertex>
          vec3 p = position;
          float h = 0.0;
          #ifdef USE_UV
          vec3 c = texture2D(uMap, vUv).rgb;
          h = (c.r + c.g + c.b) / 3.0;
          #endif
          // apply small XY jitter in object space based on vUv
          if (uJitter > 0.0) {
            float jx = hash(vUv + 0.123) * uJitter;
            float jz = hash(vUv + 4.567) * uJitter;
            p.x += jx;
            p.z += jz;
          }
          // base height
          float baseY = h * uScale + uBias;
          p.y = baseY;
          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mvPosition;
      gl_PointSize = max(1.0, uPointSize * (300.0 / max(1.0, -mvPosition.z)));
          vec4 worldPos = modelMatrix * vec4(p, 1.0);
          float d = length(worldPos.xz - uMaskCenter);
          float edge0 = uMaskRadius;
          float edge1 = uMaskRadius + max(0.0001, uMaskFeather);
          vMaskAlpha = 1.0 - smoothstep(edge0, edge1, d);
          // mouse hover influence factor 0..1 with soft falloff
          float hd = length(worldPos.xz - uHoverCenter);
          float hEdge = uHoverRadius;
          vHoverMix = uHoverEnabled * (1.0 - smoothstep(hEdge, hEdge + 0.5, hd));
          // airplane hover - distance in XZ plane from airplane
          float airDist = length(worldPos.xz - uAirplanePos.xz);
          float airEdge = uAirplaneHoverRadius;
          vAirplaneMix = uAirplaneHoverEnabled * (1.0 - smoothstep(airEdge, airEdge + 0.8, airDist));
          // proximity factor: how close is the particle to airplane vertically (0=far, 1=close)
          // Use signed distance - particles ABOVE airplane are far (green), BELOW or at same level are close (red)
          float vertDist = uAirplanePos.y - worldPos.y; // positive when airplane is above particle
          vAirplaneProximity = 1.0 - clamp(vertDist / 0.6, 0.0, 1.0); // 0=airplane high above, 1=at or below particle
          
          // Radar pulse - expanding ring from origin with rain animation
          float radarDist = length(worldPos.xz - uRadarOrigin.xz);
          float innerEdge = uRadarRadius - uRadarRingWidth;
          float outerEdge = uRadarRadius + uRadarRingWidth;
          
          // Calculate when the radar ring reached this particle
          float ringArrivalTime = radarDist / max(0.1, uRadarExpandSpeed);
          float timeSinceArrival = uRadarTime - ringArrivalTime;
          
          // Default opacity and color blend (fully visible, final color when not in radar animation)
          vRadarRainOpacity = 1.0;
          vRainColorBlend = 1.0;
          
          // Rain animation: only apply to particles OUTSIDE the mask (additive reveal)
          // Particles inside mask stay in place, particles outside get rain effect
          bool isOutsideMask = vMaskAlpha < 0.5;
          
          if (uRadarActive > 0.5 && timeSinceArrival > -0.1 && isOutsideMask) {
            // Add slight randomized delay based on position for organic feel
            float randDelay = hash(vUv * 7.89) * 0.15;
            float delayedTime = timeSinceArrival - randDelay;
            float delayedProgress = clamp(delayedTime / max(0.01, uRadarRainDuration), 0.0, 1.0);
            // Easing: fast start, smooth landing (ease-out cubic)
            float delayedEased = 1.0 - pow(1.0 - delayedProgress, 3.0);
            float rainOffset = uRadarRainHeight * (1.0 - delayedEased);
            
            // Opacity ramps from 0 to 1 as particles fall into place
            vRadarRainOpacity = delayedEased;
            
            // Color crossfade: starts after landing, transitions over uRainColorFadeDuration
            // Time since particle landed (delayedEased reached 1.0)
            float landingTime = randDelay + uRadarRainDuration;
            float timeSinceLanding = max(0.0, delayedTime - uRadarRainDuration);
            float colorFadeProgress = clamp(timeSinceLanding / max(0.01, uRainColorFadeDuration), 0.0, 1.0);
            // 0 = rain color, 1 = ring/final color
            vRainColorBlend = colorFadeProgress;
            
            // Update world position Y for the rain effect
            worldPos.y += rainOffset;
            // Also update the gl_Position and point size
            vec3 animatedP = p;
            animatedP.y = baseY + rainOffset;
            mvPosition = modelViewMatrix * vec4(animatedP, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            // Scale up point size while falling (for visible rain dashes), shrink to normal when landed
            // Use same curve as shape blend - stay large while falling, shrink at the end
            float sizeBlend = smoothstep(0.7, 1.0, delayedEased);
            float fallScale = mix(uRainParticleScale, 1.0, sizeBlend);
            gl_PointSize = max(1.0, uPointSize * fallScale * (300.0 / max(1.0, -mvPosition.z)));
          }
          
          // Ring effect: particles within the ring band (with feathering)
          float feather = max(0.1, uRadarRingFeather);
          float ringMix = smoothstep(innerEdge - feather, innerEdge, radarDist) 
                        * (1.0 - smoothstep(outerEdge, outerEdge + feather, radarDist));
          // Also show particles that the ring has passed over (persistent reveal)
          float revealMix = 1.0 - smoothstep(outerEdge - feather * 0.5, outerEdge + feather, radarDist);
          vRadarMix = uRadarActive * max(ringMix * 1.5, revealMix * 0.8);
          // Height for coloring (normalized 0-1 based on final world Y, not animated)
          vRadarHeight = clamp((baseY + 1.0) / 3.0, 0.0, 1.0);
          #include <fog_vertex>
        }
      `,
      fragmentShader: `
        uniform vec3 uColor;
        uniform vec3 uHoverColor;
        uniform vec3 uAirplaneColorFar;
        uniform vec3 uAirplaneColorClose;
        uniform float uRadarFade;
        uniform float uRadarShowRing;
        uniform vec3 uRainColor;
        uniform vec3 uRadarRingColorLow;
        uniform vec3 uRadarRingColorMid;
        uniform vec3 uRadarRingColorHigh;
        uniform float uRainParticleWidth;
        uniform float uRainParticleHeight;
        varying float vMaskAlpha;
        varying float vHoverMix;
        varying float vAirplaneMix;
        varying float vAirplaneProximity;
        varying float vRadarMix;
        varying float vRadarHeight;
        varying float vRadarRainOpacity;
        varying float vRainColorBlend;
        #include <fog_pars_fragment>
        void main() {
          vec2 pc = gl_PointCoord - 0.5;
          float r = length(pc);
          
          // Disc shape (normal point)
          float disc = 1.0 - smoothstep(0.45, 0.5, r);
          
          // Vertical line shape (rain streak) - elongated dash
          // Narrow in X (width), tall in Y (height)
          float xMask = 1.0 - smoothstep(uRainParticleWidth, uRainParticleWidth + 0.04, abs(pc.x));
          float yMask = 1.0 - smoothstep(uRainParticleHeight, uRainParticleHeight + 0.05, abs(pc.y));
          float lineMask = xMask * yMask;
          
          // Shape transition: stay as line longer, then quickly morph to disc at the end
          // Use a curve that keeps it as a line for most of the fall
          float shapeBlend = smoothstep(0.7, 1.0, vRadarRainOpacity);
          float shape = mix(lineMask, disc, shapeBlend);
          
          // Radar can reveal particles beyond the mask
          float radarAlpha = vRadarMix * uRadarFade;
          float effectiveAlpha = max(vMaskAlpha, radarAlpha);
          
          // Rain opacity: start more visible (0.5) and ramp to full
          // This ensures lines are visible during the fall
          float rainAlpha = mix(0.5, 1.0, vRadarRainOpacity);
          float alpha = shape * effectiveAlpha * rainAlpha;
          if (alpha <= 0.001) discard;
          
          // Start with base color
          vec3 col = uColor;
          // Apply mouse hover color
          col = mix(col, uHoverColor, vHoverMix);
          // Apply airplane hover - blend between far (orange) and close (red) based on proximity
          vec3 airplaneColor = mix(uAirplaneColorFar, uAirplaneColorClose, vAirplaneProximity);
          col = mix(col, airplaneColor, vAirplaneMix);
          
          // Rain color - applied to falling particles, crossfades to ring/base color
          // vRainColorBlend: 0 = rain color, 1 = final color
          if (vRainColorBlend < 1.0) {
            // Calculate the target color (ring color if enabled, otherwise base)
            vec3 targetColor = col;
            if (uRadarShowRing > 0.5) {
              targetColor = vRadarHeight < 0.5 
                ? mix(uRadarRingColorLow, uRadarRingColorMid, vRadarHeight * 2.0)
                : mix(uRadarRingColorMid, uRadarRingColorHigh, (vRadarHeight - 0.5) * 2.0);
            }
            // Crossfade from rain color to target color
            col = mix(uRainColor, targetColor, vRainColorBlend);
          } else if (uRadarShowRing > 0.5) {
            // Fully transitioned, apply ring color if enabled
            vec3 radarColor = vRadarHeight < 0.5 
              ? mix(uRadarRingColorLow, uRadarRingColorMid, vRadarHeight * 2.0)
              : mix(uRadarRingColorMid, uRadarRingColorHigh, (vRadarHeight - 0.5) * 2.0);
            col = mix(col, radarColor, radarAlpha * 0.9);
          }
          
          gl_FragColor = vec4(col, alpha);
          #include <fog_fragment>
        }
      `
    });
    // Enable UV chunks in shader includes
    pointMaterial.defines = pointMaterial.defines || {};
    pointMaterial.defines.USE_UV = '';
    

    // (Trail system removed)

    // ========== AIRPLANE ==========
    let airplane = null;
    let airplaneGroup = null;
    const airplaneState = {
      enabled: false,
      x: 0,          // current X position (world space offset from center)
      targetX: 0,    // target X position
      y: 0,          // current Y offset (altitude adjustment)
      targetY: 0,    // target Y offset
      tilt: 0,       // current tilt (roll) angle
      pitch: 0,      // current pitch angle
      speed: 3,      // horizontal movement speed
      vertSpeed: 2,  // vertical movement speed
      maxOffset: 5.5,  // max left/right offset
      altitudeRange: 1.5, // max up/down range
      smoothing: 8,  // lerp smoothing factor
      height: -2.5,  // height offset from camera
      size: 0.4,     // scale of the airplane
      distance: 3.5, // distance ahead of camera
      // Chase cam world position (used when chase cam is on)
      worldPos: new THREE.Vector3(0, 1.5, 0),
      baseAltitude: 1.5, // base flying altitude in chase cam mode
      // Collision state
      isColliding: false,
      collisionShake: 0,
      collisionThreshold: -0.1, // negative = only trigger when actually below terrain
    };
    
    // Store airplane materials for color change on collision
    let airplaneMaterials = [];
    const keysPressed = { left: false, right: false, up: false, down: false };
    
    // Radar pulse state
    const radarState = {
      active: false,
      startTime: 0,
      expandDuration: 3.6,    // seconds to expand to full radius
      persistDuration: 2.0,   // seconds to persist after expansion
      fadeDuration: 0.5,      // seconds to fade out
      maxRadius: 35.0,        // max expansion radius
      expandSpeed: 9.72,      // units per second (maxRadius / expandDuration)
      rainHeight: 41.0,       // how high particles start above their final position
      rainDuration: 0.35,     // how long the fall animation takes
      showRing: false,        // whether to show the colored pulse ring
      ringFeather: 0.1,       // softness of the ring edges
      rainColor: '#bff4ff',   // color of falling particles
      ringColorLow: '#00ccff',  // ring color for valleys
      ringColorMid: '#00ff80',  // ring color for mid heights
      ringColorHigh: '#ffee33', // ring color for peaks
      colorFadeDuration: 1.0,   // time to crossfade from rain to ring color
      // Visual ring settings
      visualRingEnabled: true,
      visualRingColor: '#00ffff',
      visualRingWidth: 0.07,
      visualRingOpacity: 1.0,
      // Rain particle shape
      rainParticleWidth: 0.08,
      rainParticleHeight: 0.45,
      rainParticleScale: 25.0
    };
    
    // Visual expanding ring mesh
    let visualRing = null;
    let visualRingMaterial = null;
    
    function createVisualRing() {
      // Create ring geometry - we'll update inner/outer radius during animation
      const geometry = new THREE.RingGeometry(0.1, 0.2, 128);
      geometry.rotateX(-Math.PI / 2); // Lay flat on XZ plane
      
      visualRingMaterial = new THREE.ShaderMaterial({
        uniforms: {
          uColor: { value: new THREE.Color(radarState.visualRingColor) },
          uOpacity: { value: radarState.visualRingOpacity },
          uInnerRadius: { value: 0.1 },
          uOuterRadius: { value: 0.2 },
          uFeather: { value: 0.05 }
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vLocalPos;
          void main() {
            vUv = uv;
            vLocalPos = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform vec3 uColor;
          uniform float uOpacity;
          uniform float uInnerRadius;
          uniform float uOuterRadius;
          uniform float uFeather;
          varying vec2 vUv;
          varying vec3 vLocalPos;
          void main() {
            // Distance from center in local space (ring geometry is centered at local origin)
            float dist = length(vLocalPos.xz);
            
            // Soft edges
            float innerAlpha = smoothstep(uInnerRadius - uFeather, uInnerRadius + uFeather, dist);
            float outerAlpha = 1.0 - smoothstep(uOuterRadius - uFeather, uOuterRadius + uFeather, dist);
            float alpha = innerAlpha * outerAlpha * uOpacity;
            
            // Glow effect - brighter at edges
            float edgeDist = min(dist - uInnerRadius, uOuterRadius - dist);
            float edgeGlow = 1.0 + 0.5 * (1.0 - smoothstep(0.0, uFeather * 2.0, edgeDist));
            
            gl_FragColor = vec4(uColor * edgeGlow, alpha);
          }
        `,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      
      visualRing = new THREE.Mesh(geometry, visualRingMaterial);
      visualRing.visible = false;
      visualRing.renderOrder = 999; // Render on top
      scene.add(visualRing);
    }
    
    function updateVisualRing(currentRadius, fade) {
      if (!visualRing || !radarState.visualRingEnabled) {
        if (visualRing) visualRing.visible = false;
        return;
      }
      
      const width = radarState.visualRingWidth;
      const innerRadius = Math.max(0.01, currentRadius - width);
      const outerRadius = currentRadius + width;
      
      // Recreate geometry with new radii
      visualRing.geometry.dispose();
      visualRing.geometry = new THREE.RingGeometry(innerRadius, outerRadius, 128);
      visualRing.geometry.rotateX(-Math.PI / 2);
      
      // Update material uniforms
      visualRingMaterial.uniforms.uInnerRadius.value = innerRadius;
      visualRingMaterial.uniforms.uOuterRadius.value = outerRadius;
      visualRingMaterial.uniforms.uOpacity.value = radarState.visualRingOpacity * fade;
      visualRingMaterial.uniforms.uColor.value.set(radarState.visualRingColor);
      visualRingMaterial.uniforms.uFeather.value = width * 0.3;
      
      visualRing.visible = true;
    }
    
    // Initialize visual ring
    createVisualRing();

    function createAirplane() {
      // Create a retro wireframe arrow pointing forward
      const group = new THREE.Group();
      
      // Arrow outline - wireframe style like retro arcade radar
      // Arrow points forward (+Z direction after 180 flip)
      const arrowVerts = new Float32Array([
        // Arrow shape pointing forward (nose at front)
        0, 0, 0.5,        // nose (front tip)
        -0.25, 0, -0.3,   // left back corner
        0, 0, -0.15,      // center notch (back)
        
        0, 0, 0.5,        // nose (front tip)
        0, 0, -0.15,      // center notch (back)
        0.25, 0, -0.3,    // right back corner
        
        // Close the back
        -0.25, 0, -0.3,   // left back corner
        0, 0, -0.15,      // center notch
        0.25, 0, -0.3,    // right back corner
      ]);
      
      const arrowGeo = new THREE.BufferGeometry();
      arrowGeo.setAttribute('position', new THREE.BufferAttribute(arrowVerts, 3));
      
      // Wireframe material - retro arcade look
      const wireMat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity: 0.9
      });
      
      const arrow = new THREE.Mesh(arrowGeo, wireMat);
      group.add(arrow);
      
      // Store materials for collision color change
      airplaneMaterials = [wireMat];
      
      // Add edge lines for cleaner wireframe look
      const edgeVerts = new Float32Array([
        // Outline of the arrow
        0, 0, 0.5,        // nose
        -0.25, 0, -0.3,   // left back
        -0.25, 0, -0.3,   // left back
        0, 0, -0.15,      // center notch
        0, 0, -0.15,      // center notch
        0.25, 0, -0.3,    // right back
        0.25, 0, -0.3,    // right back
        0, 0, 0.5,        // back to nose
      ]);
      
      const edgeGeo = new THREE.BufferGeometry();
      edgeGeo.setAttribute('position', new THREE.BufferAttribute(edgeVerts, 3));
      
      const lineMat = new THREE.LineBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 1.0,
        linewidth: 2
      });
      
      const edges = new THREE.LineSegments(edgeGeo, lineMat);
      group.add(edges);
      
      // Add line material to stored materials
      airplaneMaterials.push(lineMat);
      
      // Scale based on airplaneState.size
      group.scale.set(airplaneState.size, airplaneState.size, airplaneState.size);
      
      return group;
    }

    function initAirplane() {
      if (airplaneGroup) {
        scene.remove(airplaneGroup);
        airplaneGroup = null;
      }
      airplaneGroup = createAirplane();
      airplaneGroup.visible = airplaneState.enabled;
      scene.add(airplaneGroup);
    }

    function updateAirplane(delta) {
      if (!airplaneGroup || !airplaneState.enabled) return;
      
      const isChaseMode = params.cameraMode === 'chase';
      const isTopdownMode = params.cameraMode === 'topdown';
      const isIsoMode = params.cameraMode === 'isometric';
      
      // Handle horizontal input - update target position
      if (keysPressed.left) {
        airplaneState.targetX = Math.max(-airplaneState.maxOffset, airplaneState.targetX - airplaneState.speed * delta);
      }
      if (keysPressed.right) {
        airplaneState.targetX = Math.min(airplaneState.maxOffset, airplaneState.targetX + airplaneState.speed * delta);
      }
      
      // Handle vertical input - update target altitude
      if (keysPressed.up) {
        airplaneState.targetY = Math.min(airplaneState.altitudeRange, airplaneState.targetY + airplaneState.vertSpeed * delta);
      }
      if (keysPressed.down) {
        airplaneState.targetY = Math.max(-airplaneState.altitudeRange, airplaneState.targetY - airplaneState.vertSpeed * delta);
      }
      
      // Smooth horizontal movement toward target
      const dx = airplaneState.targetX - airplaneState.x;
      airplaneState.x += dx * Math.min(1, airplaneState.smoothing * delta);
      
      // Smooth vertical movement toward target
      const dy = airplaneState.targetY - airplaneState.y;
      airplaneState.y += dy * Math.min(1, airplaneState.smoothing * delta);
      
      // Calculate tilt based on movement direction (bank into turns like real airplane)
      const targetTilt = dx * 1.25; // reversed tilt, reduced by 50%
      airplaneState.tilt += (targetTilt - airplaneState.tilt) * Math.min(1, 6 * delta);
      
      // Calculate pitch based on vertical movement
      const targetPitch = -dy * 0.8; // nose up when climbing, down when diving
      airplaneState.pitch += (targetPitch - airplaneState.pitch) * Math.min(1, 6 * delta);
      
      // Get forward direction for movement and orientation
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      if (forward.lengthSq() < 1e-6) forward.set(0, 0, -1);
      forward.normalize();
      
      // Get right vector
      const right = new THREE.Vector3();
      right.crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();
      
      if (isChaseMode || isTopdownMode || isIsoMode) {
        // All airplane-following modes: airplane strafes left/right, always faces forward
        // Use fixed forward direction (scroll direction is -Z)
        const chaseForward = new THREE.Vector3(0, 0, -1);
        const chaseRight = new THREE.Vector3(1, 0, 0);
        
        // Strafe position directly using airplaneState.x
        airplaneState.worldPos.x = airplaneState.x;
        airplaneState.worldPos.y = airplaneState.baseAltitude + airplaneState.y;
        // Z stays at 0 (airplane stays in place, terrain scrolls past)
        
        // Set airplane position from world pos
        airplaneGroup.position.copy(airplaneState.worldPos);
        
        // Override forward for orientation (always face forward)
        forward.copy(chaseForward);
        right.copy(chaseRight);
      } else {
        // Normal mode: airplane positioned relative to camera
        airplaneGroup.position.copy(camera.position);
        airplaneGroup.position.addScaledVector(forward, airplaneState.distance);
        airplaneGroup.position.addScaledVector(right, airplaneState.x);
        airplaneGroup.position.y = camera.position.y + airplaneState.height + airplaneState.y;
      }
      
      // Update scale
      airplaneGroup.scale.set(airplaneState.size, airplaneState.size, airplaneState.size);
      
      // Orient airplane to face forward direction with tilt and pitch
      const lookTarget = airplaneGroup.position.clone().add(forward);
      airplaneGroup.lookAt(lookTarget);
      airplaneGroup.rotation.z = airplaneState.tilt;
      airplaneGroup.rotation.x += airplaneState.pitch;
      
      const time = performance.now() * 0.001;
      
      // Collision detection - sample actual terrain height at airplane position
      const terrainHeight = sampleTerrainHeight(airplaneGroup.position.x, airplaneGroup.position.z);
      
      const wasColliding = airplaneState.isColliding;
      if (terrainHeight !== null) {
        // Compare airplane Y to actual terrain height at this position
        const clearance = airplaneGroup.position.y - terrainHeight;
        airplaneState.isColliding = clearance < airplaneState.collisionThreshold;
      } else {
        airplaneState.isColliding = false; // No heightmap yet
      }
      
      // Handle collision effects
      // Get target colors from uniforms (which are synced with params)
      const dangerColor = pointMaterial.uniforms.uAirplaneColorClose.value;
      const safeColor = pointMaterial.uniforms.uAirplaneColorFar.value;
      
      if (airplaneState.isColliding) {
        // Increase shake intensity
        airplaneState.collisionShake = Math.min(airplaneState.collisionShake + delta * 15, 1.0);
        
        // Turn airplane to danger color
        for (const mat of airplaneMaterials) {
          mat.color.copy(dangerColor);
        }
        
        // Apply shake
        const shakeIntensity = airplaneState.collisionShake * 0.08;
        airplaneGroup.position.x += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.position.y += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.position.z += (Math.random() - 0.5) * shakeIntensity;
        airplaneGroup.rotation.z += (Math.random() - 0.5) * shakeIntensity * 0.5;
      } else {
        // Decay shake when not colliding
        airplaneState.collisionShake = Math.max(airplaneState.collisionShake - delta * 5, 0);
        
        // Transition to safe color smoothly
        for (const mat of airplaneMaterials) {
          const currentColor = mat.color;
          currentColor.r += (safeColor.r - currentColor.r) * delta * 5;
          currentColor.g += (safeColor.g - currentColor.g) * delta * 5;
          currentColor.b += (safeColor.b - currentColor.b) * delta * 5;
        }
        
        // Add subtle bobbing motion only when not colliding
        airplaneGroup.position.y += Math.sin(time * 2) * 0.02;
      }
    }

    // Keyboard controls for airplane
    window.addEventListener('keydown', (e) => {
      // Prevent spacebar from scrolling page
      if (e.code === 'Space') {
        e.preventDefault();
      }
      if (!airplaneState.enabled) return;
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        keysPressed.left = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        keysPressed.right = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysPressed.up = true;
        e.preventDefault();
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysPressed.down = true;
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
        keysPressed.left = false;
      }
      if (e.code === 'ArrowRight' || e.code === 'KeyD') {
        keysPressed.right = false;
      }
      if (e.code === 'ArrowUp' || e.code === 'KeyW') {
        keysPressed.up = false;
      }
      if (e.code === 'ArrowDown' || e.code === 'KeyS') {
        keysPressed.down = false;
      }
      // G key cycles camera modes
      if (e.code === 'KeyG') {
        cycleCameraMode();
      }
      // Spacebar triggers radar pulse
      if (e.code === 'Space') {
        triggerRadarPulse();
        e.preventDefault();
      }
    });
    
    function triggerRadarPulse() {
      // Get origin from airplane position or camera position
      let origin;
      if (airplaneGroup && airplaneState.enabled) {
        // Read directly from airplaneState which has the current position
        const isChaseStyle = params.cameraMode === 'chase' || params.cameraMode === 'topdown' || params.cameraMode === 'isometric';
        if (isChaseStyle) {
          // In chase modes, use the strafe position (x) and z=0 since terrain scrolls
          origin = new THREE.Vector3(
            airplaneState.x,
            airplaneState.baseAltitude + airplaneState.y,
            0
          );
        } else {
          origin = airplaneGroup.position.clone();
        }
      } else {
        origin = camera.position.clone();
        origin.y = 0;
      }
      
      radarState.active = true;
      radarState.startTime = performance.now() * 0.001;
      // Update expand speed based on current settings
      radarState.expandSpeed = radarState.maxRadius / radarState.expandDuration;
      
      pointMaterial.uniforms.uRadarActive.value = 1.0;
      pointMaterial.uniforms.uRadarOrigin.value.copy(origin);
      pointMaterial.uniforms.uRadarRadius.value = 0.0;
      pointMaterial.uniforms.uRadarFade.value = 1.0;
      pointMaterial.uniforms.uRadarTime.value = 0.0;
      pointMaterial.uniforms.uRadarRainHeight.value = radarState.rainHeight;
      pointMaterial.uniforms.uRadarRainDuration.value = radarState.rainDuration;
      pointMaterial.uniforms.uRadarExpandSpeed.value = radarState.expandSpeed;
      pointMaterial.uniforms.uRadarShowRing.value = radarState.showRing ? 1.0 : 0.0;
      pointMaterial.uniforms.uRadarRingFeather.value = radarState.ringFeather;
      pointMaterial.uniforms.uRainColor.value.set(radarState.rainColor);
      pointMaterial.uniforms.uRadarRingColorLow.value.set(radarState.ringColorLow);
      pointMaterial.uniforms.uRadarRingColorMid.value.set(radarState.ringColorMid);
      pointMaterial.uniforms.uRadarRingColorHigh.value.set(radarState.ringColorHigh);
      pointMaterial.uniforms.uRainColorFadeDuration.value = radarState.colorFadeDuration;
      pointMaterial.uniforms.uRainParticleWidth.value = radarState.rainParticleWidth;
      pointMaterial.uniforms.uRainParticleHeight.value = radarState.rainParticleHeight;
      pointMaterial.uniforms.uRainParticleScale.value = radarState.rainParticleScale;
      
      // Position visual ring at origin, at airplane altitude
      if (visualRing) {
        visualRing.position.set(origin.x, origin.y, origin.z);
        visualRing.visible = radarState.visualRingEnabled;
      }
    }
    
    function cycleCameraMode() {
      const modes = ['chase', 'topdown', 'isometric'];
      const currentIndex = modes.indexOf(params.cameraMode);
      const nextIndex = (currentIndex + 1) % modes.length;
      setCameraMode(modes[nextIndex]);
    }
    
    function setCameraMode(mode) {
      params.cameraMode = mode;
      
      // All modes now follow the airplane, so always enable it
      if (!airplaneState.enabled) {
        params.airplaneEnabled = true;
        airplaneState.enabled = true;
        if (airplaneGroup) airplaneGroup.visible = true;
      }
      // Reset airplane state when switching modes
      airplaneState.x = 0;
      airplaneState.targetX = 0;
      airplaneState.y = 0;
      airplaneState.targetY = 0;
      airplaneState.tilt = 0;
      airplaneState.pitch = 0;
      airplaneState.worldPos.set(0, airplaneState.baseAltitude, 0);
      // Reset camera orbit when switching modes
      cameraOrbit.azimuth = 0;
      cameraOrbit.elevation = 0;
      
      pane.refresh();
    }

    // Initialize airplane
    initAirplane();

    // Tiling with Points
    let tilesPoints = [];
    const state = { tileSize: initialSize, tilesX: 3, tilesZ: 3, scrollSpeed: 3 };
    const scrollOffset = new THREE.Vector2(0, 0);

    function buildBaseGeometry() {
      const g = new THREE.PlaneGeometry(state.tileSize, state.tileSize, segments, segments);
      g.rotateX(-Math.PI / 2);
      return g;
    }

    function positiveModulo(v, m) { return ((v % m) + m) % m; }

    function updateTileMatrices() {
      if (!tilesPoints || tilesPoints.length === 0) return;
      let idx = 0;
      const offsetX = (state.tilesX - 1) * state.tileSize * 0.5;
      const offsetZ = (state.tilesZ - 1) * state.tileSize * 0.5;
      const modX = positiveModulo(scrollOffset.x, state.tileSize);
      const modZ = positiveModulo(scrollOffset.y, state.tileSize);
      for (let z = 0; z < state.tilesZ; z++) {
        for (let x = 0; x < state.tilesX; x++) {
          const px = (x * state.tileSize) - offsetX - modX;
          const pz = (z * state.tileSize) - offsetZ - modZ;
          const pts = tilesPoints[idx++];
          if (pts) pts.position.set(px, 0, pz);
        }
      }
    }

    function rebuildTiling() {
      if (tilesPoints && tilesPoints.length) {
        for (const p of tilesPoints) {
          scene.remove(p);
          if (p.geometry) p.geometry.dispose();
        }
      }
      tilesPoints = [];
      const geometry = buildBaseGeometry();
      geometry.deleteAttribute('normal');
      geometry.deleteAttribute('tangent');
      // Ensure each vertex becomes a point; PlaneGeometry already has indexed triangles.
      // Convert to non-indexed so every vertex is unique for gl.POINTS
      const nonIndexed = geometry.toNonIndexed();
      nonIndexed.computeBoundingSphere();
      for (let z = 0; z < state.tilesZ; z++) {
        for (let x = 0; x < state.tilesX; x++) {
          const pts = new THREE.Points(nonIndexed, pointMaterial);
          pts.frustumCulled = false;
          tilesPoints.push(pts);
          scene.add(pts);
        }
      }
      updateTileMatrices();
    }

    rebuildTiling();

    // (Car and follower removed)

    // (CPU height sampling removed)

    // (Cursor/mouse following removed)

    // UI elements
    const fileInput = document.getElementById('heightmapFile');

    // Tweakpane setup
    const panelContainer = document.getElementById('panel-container');
    const pane = new Pane({ title: 'Particle Landscape', container: panelContainer });
    
    // Parameters object
    const params = {
      // Heightmap
      terrainColor: '#8a8f9a',
      scale: 1.4,
      tileSize: 11,
      tilesX: 1,
      tilesZ: 3,
      // Particles
      pointSize: 0.01,
      jitter: 0.02,
      hoverRadius: 1.6,
      hoverStrength: 0.8,
      hoverSnap: 2.0,
      hoverColor: '#ffcc55',
      cols: 416,
      rows: 416,
      // Mask
      maskRadius: 3.0,
      maskFeather: 0.8,
      // Animation
      scrollSpeed: 0.6,
      animateScroll: true,
      // Camera
      camYaw: 0,
      camPitch: -41,
      camFov: 90,
      camHeight: 3.0,
      camZ: 5.4,
      // Fog
      fogEnabled: true,
      fogColor: '#0e0f13',
      fogNear: 12,
      fogFar: 1,
      // Camera modes: 'chase', 'topdown', 'isometric'
      cameraMode: 'chase',
      chaseCamDistance: 2.5,
      chaseCamHeight: 0.8,
      chaseCamAltitude: 1.5,
      topCamHeight: 8,
      isoCamDistance: 6,
      isoCamHeight: 4,
      // Airplane
      airplaneEnabled: false,
      airplaneSpeed: 3,
      airplaneMaxOffset: 5.5,
      airplaneVertSpeed: 2,
      airplaneAltitudeRange: 1.5,
      airplaneHeight: -2.5,
      airplaneSize: 0.4,
      airplaneDistance: 3.5,
      // Hover highlights
      mouseHoverEnabled: false,
      airplaneHoverEnabled: true,
      airplaneHoverRadius: 2.0,
      airplaneColorSafe: '#00ffaa',   // cyan-green when high/safe
      airplaneColorDanger: '#ff0000', // red when low/danger
    };

    // Helper functions
    const degToRad = (d) => d * Math.PI / 180;
    const clampPitchDeg = (p) => Math.max(-89, Math.min(89, p));
    function applyYawPitchDeg(yawDeg, pitchDeg) {
      const yaw = degToRad(yawDeg);
      const pitch = degToRad(clampPitchDeg(pitchDeg));
      const e = new THREE.Euler(pitch, yaw, 0, 'YXZ');
      camera.quaternion.setFromEuler(e);
    }

    function clampPowerOfTwo(n) {
      return Math.max(2, Math.min(2048, Math.floor(n)));
    }

    function applyFogFromParams() {
      if (params.fogEnabled) {
        scene.fog = new THREE.Fog(
          params.fogColor, 
          Math.min(params.fogNear, params.fogFar - 0.001), 
          Math.max(params.fogNear + 0.001, params.fogFar)
        );
        scene.background = new THREE.Color(params.fogColor);
      } else {
        scene.fog = null;
      }
    }

    // Heightmap folder
    const heightmapFolder = pane.addFolder({ title: 'Heightmap', expanded: true });
    heightmapFolder.addButton({ title: 'Load Heightmap...' }).on('click', () => {
      fileInput.click();
    });
    heightmapFolder.addBinding(params, 'terrainColor', { view: 'color' }).on('change', (ev) => {
      pointMaterial.uniforms.uColor.value.set(ev.value);
    });
    heightmapFolder.addBinding(params, 'scale', { min: 0, max: 8, step: 0.1 }).on('change', (ev) => {
      pointMaterial.uniforms.uScale.value = ev.value;
      pointMaterial.uniforms.uBias.value = -ev.value * 0.5;
    });
    heightmapFolder.addBinding(params, 'tileSize', { min: 2, max: 50, step: 1 }).on('change', (ev) => {
      state.tileSize = Math.max(1, ev.value);
      rebuildTiling();
    });
    heightmapFolder.addBinding(params, 'tilesX', { min: 1, max: 20, step: 1 }).on('change', (ev) => {
      state.tilesX = Math.max(1, Math.min(20, ev.value));
      rebuildTiling();
    });
    heightmapFolder.addBinding(params, 'tilesZ', { min: 1, max: 20, step: 1 }).on('change', (ev) => {
      state.tilesZ = Math.max(1, Math.min(20, ev.value));
      rebuildTiling();
    });

    // Particles folder
    const particlesFolder = pane.addFolder({ title: 'Particles', expanded: true });
    particlesFolder.addBinding(params, 'pointSize', { min: 0, max: 0.5, step: 0.01, label: 'Point Size' }).on('change', (ev) => {
      pointMaterial.uniforms.uPointSize.value = ev.value;
    });
    particlesFolder.addBinding(params, 'jitter', { min: 0.0, max: 0.2, step: 0.001 }).on('change', (ev) => {
      pointMaterial.uniforms.uJitter.value = ev.value;
    });
    particlesFolder.addBlade({ view: 'separator' });
    particlesFolder.addBinding(params, 'hoverRadius', { min: 0.1, max: 10, step: 0.1, label: 'Hover Radius' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverRadius.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverStrength', { min: 0, max: 10, step: 0.1, label: 'Hover Strength' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverStrength.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverSnap', { min: 0.1, max: 10, step: 0.1, label: 'Hover Snap' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverSnap.value = ev.value;
    });
    particlesFolder.addBinding(params, 'hoverColor', { view: 'color', label: 'Hover Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverColor.value.set(ev.value);
    });
    particlesFolder.addBinding(params, 'mouseHoverEnabled', { label: 'Mouse Hover' }).on('change', (ev) => {
      pointMaterial.uniforms.uHoverEnabled.value = ev.value ? 1.0 : 0.0;
    });
    particlesFolder.addBlade({ view: 'separator' });
    particlesFolder.addBinding(params, 'cols', { min: 8, max: 1024, step: 8 }).on('change', (ev) => {
      params.cols = clampPowerOfTwo(ev.value);
      segments = Math.max(2, Math.max(params.cols, params.rows));
      rebuildTiling();
    });
    particlesFolder.addBinding(params, 'rows', { min: 8, max: 1024, step: 8 }).on('change', (ev) => {
      params.rows = clampPowerOfTwo(ev.value);
      segments = Math.max(2, Math.max(params.cols, params.rows));
      rebuildTiling();
    });

    // Mask folder
    const maskFolder = pane.addFolder({ title: 'Mask', expanded: true });
    maskFolder.addBinding(params, 'maskRadius', { min: 0.1, max: 20, step: 0.1, label: 'Mask Radius' }).on('change', (ev) => {
      pointMaterial.uniforms.uMaskRadius.value = ev.value;
    });
    maskFolder.addBinding(params, 'maskFeather', { min: 0.0, max: 5, step: 0.1, label: 'Mask Feather' }).on('change', (ev) => {
      pointMaterial.uniforms.uMaskFeather.value = ev.value;
    });

    // Animation folder
    const animationFolder = pane.addFolder({ title: 'Animation', expanded: true });
    animationFolder.addBinding(params, 'scrollSpeed', { min: -20, max: 20, step: 0.1, label: 'Scroll Speed' }).on('change', (ev) => {
      state.scrollSpeed = ev.value;
    });
    animationFolder.addBinding(params, 'animateScroll', { label: 'Animate' });

    // Airplane folder
    const airplaneFolder = pane.addFolder({ title: 'Airplane', expanded: true });
    airplaneFolder.addBinding(params, 'airplaneEnabled', { label: 'Enable Airplane' }).on('change', (ev) => {
      airplaneState.enabled = ev.value;
      if (airplaneGroup) airplaneGroup.visible = ev.value;
      // Reset position when toggled on
      if (ev.value) {
        airplaneState.x = 0;
        airplaneState.targetX = 0;
        airplaneState.y = 0;
        airplaneState.targetY = 0;
        airplaneState.tilt = 0;
        airplaneState.pitch = 0;
      }
    });
    airplaneFolder.addBinding(params, 'airplaneSpeed', { min: 1, max: 20, step: 0.5, label: 'Move Speed' }).on('change', (ev) => {
      airplaneState.speed = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneMaxOffset', { min: 1, max: 15, step: 0.5, label: 'Max Offset' }).on('change', (ev) => {
      airplaneState.maxOffset = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneVertSpeed', { min: 0.5, max: 5, step: 0.1, label: 'Vert Speed' }).on('change', (ev) => {
      airplaneState.vertSpeed = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneAltitudeRange', { min: 0.5, max: 5, step: 0.1, label: 'Alt Range' }).on('change', (ev) => {
      airplaneState.altitudeRange = ev.value;
    });
    airplaneFolder.addBlade({ view: 'separator' });
    airplaneFolder.addBinding(params, 'airplaneHeight', { min: -5, max: 1, step: 0.1, label: 'Height' }).on('change', (ev) => {
      airplaneState.height = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneSize', { min: 0.2, max: 3, step: 0.1, label: 'Size' }).on('change', (ev) => {
      airplaneState.size = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneDistance', { min: 1, max: 10, step: 0.1, label: 'Distance' }).on('change', (ev) => {
      airplaneState.distance = ev.value;
    });
    airplaneFolder.addBlade({ view: 'separator' });
    airplaneFolder.addBinding(params, 'airplaneHoverEnabled', { label: 'Ground Highlight' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneHoverEnabled.value = ev.value ? 1.0 : 0.0;
    });
    airplaneFolder.addBinding(params, 'airplaneHoverRadius', { min: 0.5, max: 5, step: 0.1, label: 'Highlight Size' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneHoverRadius.value = ev.value;
    });
    airplaneFolder.addBinding(params, 'airplaneColorSafe', { view: 'color', label: 'Safe Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneColorFar.value.set(ev.value);
    });
    airplaneFolder.addBinding(params, 'airplaneColorDanger', { view: 'color', label: 'Danger Color' }).on('change', (ev) => {
      pointMaterial.uniforms.uAirplaneColorClose.value.set(ev.value);
    });
    airplaneFolder.addBlade({ view: 'separator' });
    const airplaneHint = airplaneFolder.addBlade({
      view: 'text',
      label: '',
      parse: (v) => String(v),
      value: ' or WASD to fly',
    });
    airplaneHint.disabled = true;
    
    // Radar folder
    const radarFolder = pane.addFolder({ title: 'Radar (Spacebar)', expanded: false });
    radarFolder.addButton({ title: ' Trigger Radar Pulse' }).on('click', triggerRadarPulse);
    radarFolder.addBinding(radarState, 'showRing', { label: 'Show Color Ring' });
    radarFolder.addBinding(radarState, 'maxRadius', { min: 10, max: 50, step: 1, label: 'Max Radius' });
    radarFolder.addBinding(radarState, 'expandDuration', { min: 0.5, max: 5, step: 0.1, label: 'Expand Time' });
    radarFolder.addBinding(radarState, 'persistDuration', { min: 1, max: 8, step: 0.5, label: 'Persist Time' });
    radarFolder.addBinding(radarState, 'fadeDuration', { min: 0.5, max: 3, step: 0.1, label: 'Fade Time' });
    radarFolder.addBinding(pointMaterial.uniforms.uRadarRingWidth, 'value', { min: 0.5, max: 5, step: 0.1, label: 'Ring Width' });
    radarFolder.addBinding(radarState, 'ringFeather', { min: 0.1, max: 5, step: 0.1, label: 'Ring Feather' });
    radarFolder.addBlade({ view: 'separator' });
    radarFolder.addBinding(radarState, 'rainHeight', { min: 2, max: 50, step: 0.5, label: 'Rain Height' });
    radarFolder.addBinding(radarState, 'rainDuration', { min: 0.1, max: 1.5, step: 0.05, label: 'Rain Speed' });
    radarFolder.addBlade({ view: 'separator' });
    radarFolder.addBinding(radarState, 'rainColor', { view: 'color', label: 'Rain Color' });
    radarFolder.addBinding(radarState, 'colorFadeDuration', { min: 0.1, max: 3, step: 0.1, label: 'Color Fade Time' });
    radarFolder.addBinding(radarState, 'ringColorLow', { view: 'color', label: 'Ring Low' });
    radarFolder.addBinding(radarState, 'ringColorMid', { view: 'color', label: 'Ring Mid' });
    radarFolder.addBinding(radarState, 'ringColorHigh', { view: 'color', label: 'Ring High' });
    radarFolder.addBlade({ view: 'separator' });
    radarFolder.addBinding(radarState, 'rainParticleWidth', { min: 0.02, max: 0.3, step: 0.01, label: 'Rain Width' });
    radarFolder.addBinding(radarState, 'rainParticleHeight', { min: 0.1, max: 0.5, step: 0.01, label: 'Rain Height' });
    radarFolder.addBinding(radarState, 'rainParticleScale', { min: 5, max: 50, step: 1, label: 'Rain Size' });
    radarFolder.addBlade({ view: 'separator' });
    radarFolder.addBinding(radarState, 'visualRingEnabled', { label: 'Visual Ring' });
    radarFolder.addBinding(radarState, 'visualRingColor', { view: 'color', label: 'V-Ring Color' });
    radarFolder.addBinding(radarState, 'visualRingWidth', { min: 0.02, max: 1.0, step: 0.01, label: 'V-Ring Width' });
    radarFolder.addBinding(radarState, 'visualRingOpacity', { min: 0.1, max: 1.0, step: 0.05, label: 'V-Ring Opacity' });

    // Camera folder
    const cameraFolder = pane.addFolder({ title: 'Camera', expanded: true });
    cameraFolder.addBinding(params, 'camYaw', { min: -180, max: 180, step: 1, label: 'Yaw' }).on('change', (ev) => {
      applyYawPitchDeg(ev.value, params.camPitch);
    });
    cameraFolder.addBinding(params, 'camPitch', { min: -89, max: 89, step: 1, label: 'Pitch' }).on('change', (ev) => {
      applyYawPitchDeg(params.camYaw, ev.value);
    });
    cameraFolder.addBinding(params, 'camFov', { min: 20, max: 100, step: 1, label: 'FOV' }).on('change', (ev) => {
      camera.fov = ev.value;
      camera.updateProjectionMatrix();
    });
    cameraFolder.addBinding(params, 'camHeight', { min: 0, max: 100, step: 0.1, label: 'Height' }).on('change', (ev) => {
      camera.position.y = ev.value;
    });
    cameraFolder.addBinding(params, 'camZ', { min: -200, max: 200, step: 0.1, label: 'Camera Z' }).on('change', (ev) => {
      camera.position.z = ev.value;
    });
    cameraFolder.addBlade({ view: 'separator' });
    cameraFolder.addBinding(params, 'fogEnabled', { label: 'Fog Enabled' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogColor', { view: 'color', label: 'Fog Color' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogNear', { min: 0, max: 500, step: 1, label: 'Fog Near' }).on('change', applyFogFromParams);
    cameraFolder.addBinding(params, 'fogFar', { min: 1, max: 1000, step: 1, label: 'Fog Far' }).on('change', applyFogFromParams);
    cameraFolder.addBlade({ view: 'separator' });
    cameraFolder.addButton({ title: 'Reset Camera' }).on('click', () => {
      camera.position.copy(defaultCamPos);
      camera.quaternion.copy(defaultCamQuat);
      const e = new THREE.Euler().setFromQuaternion(camera.quaternion, 'YXZ');
      params.camYaw = Math.round(THREE.MathUtils.radToDeg(e.y));
      params.camPitch = Math.round(THREE.MathUtils.radToDeg(e.x));
      params.camFov = Math.round(camera.fov);
      params.camHeight = camera.position.y;
      params.camZ = camera.position.z;
      params.cameraMode = 'chase';
      // Reset camera orbit
      cameraOrbit.azimuth = 0;
      cameraOrbit.elevation = 0;
      pane.refresh();
      scrollOffset.set(0, 0);
      updateTileMatrices();
    });
    cameraFolder.addBlade({ view: 'separator' });
    cameraFolder.addBinding(params, 'cameraMode', { 
      label: 'Camera Mode (G)', 
      options: { 'Chase': 'chase', 'Top-Down': 'topdown', 'Isometric': 'isometric' }
    }).on('change', (ev) => {
      setCameraMode(ev.value);
    });
    cameraFolder.addBinding(params, 'chaseCamDistance', { min: 0.5, max: 8, step: 0.1, label: 'Chase Distance' });
    cameraFolder.addBinding(params, 'chaseCamHeight', { min: 0.2, max: 3, step: 0.1, label: 'Chase Height' });
    cameraFolder.addBinding(params, 'topCamHeight', { min: 3, max: 20, step: 0.5, label: 'Top-Down Height' });
    cameraFolder.addBinding(params, 'isoCamDistance', { min: 2, max: 15, step: 0.5, label: 'Iso Distance' });
    cameraFolder.addBinding(params, 'isoCamHeight', { min: 1, max: 10, step: 0.5, label: 'Iso Height' });
    cameraFolder.addBinding(params, 'chaseCamAltitude', { min: 0.5, max: 5, step: 0.1, label: 'Flight Altitude' }).on('change', (ev) => {
      airplaneState.baseAltitude = ev.value;
    });

    // ---- URL parameter configuration ----
    // Allows setting values via query params and optionally hiding the UI
    (function applyUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);

      function setParam(key, paramName) {
        if (urlParams.has(paramName)) {
          const value = urlParams.get(paramName);
          if (typeof params[key] === 'boolean') {
            params[key] = value === '1' || value === 'true' || value === 'on';
        } else {
            params[key] = Number(value) || value;
          }
        }
      }

      // hide UI if ui=0
      if (urlParams.get('ui') === '0') {
        pane.hidden = true;
      }

      // common controls
      setParam('scale', 'scale');
      setParam('tileSize', 'tileSize');
      setParam('tilesX', 'tilesX');
      setParam('tilesZ', 'tilesZ');
      setParam('pointSize', 'psize');
      setParam('maskRadius', 'mask');
      setParam('maskFeather', 'feather');
      setParam('jitter', 'jitter');
      setParam('hoverRadius', 'hR');
      setParam('hoverStrength', 'hS');
      setParam('hoverSnap', 'hSnap');
      setParam('camYaw', 'yaw');
      setParam('camPitch', 'pitch');
      setParam('camFov', 'fov');
      setParam('camHeight', 'height');
      setParam('camZ', 'z');
      setParam('scrollSpeed', 'scroll');
      setParam('animateScroll', 'animate');
      setParam('cols', 'cols');
      setParam('rows', 'rows');
      setParam('fogEnabled', 'fog');
      setParam('fogNear', 'near');
      setParam('fogFar', 'far');
      // colors as hex
      if (urlParams.has('terrain')) {
        params.terrainColor = urlParams.get('terrain');
      }
      if (urlParams.has('fogColor')) {
        params.fogColor = urlParams.get('fogColor');
      }

      // Refresh pane to show URL param values
      pane.refresh();
    })();

    // Initialize camera and scene from param defaults
    (function initFromDefaults() {
      // Apply yaw/pitch
      applyYawPitchDeg(params.camYaw, params.camPitch);
      // Apply FOV
      camera.fov = params.camFov;
      camera.updateProjectionMatrix();
      // Apply height & camera Z
      camera.position.y = params.camHeight;
      camera.position.z = params.camZ;
      // Apply scroll speed
      state.scrollSpeed = params.scrollSpeed;
      // Grid visibility
      grid.visible = false;
      // Scale
      pointMaterial.uniforms.uScale.value = params.scale;
      pointMaterial.uniforms.uBias.value = -params.scale * 0.5;
      // Point color default
      pointMaterial.uniforms.uColor.value.set(params.terrainColor);
      // Jitter default
      pointMaterial.uniforms.uJitter.value = params.jitter;
      // Point defaults
      pointMaterial.uniforms.uPointSize.value = params.pointSize;
      pointMaterial.uniforms.uMaskRadius.value = params.maskRadius;
      pointMaterial.uniforms.uMaskFeather.value = params.maskFeather;
      // Hover defaults
      pointMaterial.uniforms.uHoverRadius.value = params.hoverRadius;
      pointMaterial.uniforms.uHoverStrength.value = params.hoverStrength;
      pointMaterial.uniforms.uHoverSnap.value = params.hoverSnap;
      pointMaterial.uniforms.uHoverColor.value.set(params.hoverColor);
      pointMaterial.uniforms.uHoverEnabled.value = params.mouseHoverEnabled ? 1.0 : 0.0;
      // Airplane hover defaults
      pointMaterial.uniforms.uAirplaneHoverEnabled.value = params.airplaneHoverEnabled ? 1.0 : 0.0;
      pointMaterial.uniforms.uAirplaneHoverRadius.value = params.airplaneHoverRadius;
      
      // Record defaults for Reset
      defaultCamPos = new THREE.Vector3().copy(camera.position);
      defaultCamQuat = new THREE.Quaternion().copy(camera.quaternion);
      // Initialize fog state
      applyFogFromParams();
      // Compile shader after defines updates
      pointMaterial.needsUpdate = true;
      // Load default heightmap texture
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        DEFAULT_HEIGHTMAP_URL,
        (tex) => {
          applyHeightmapTexture(tex).catch((err) => console.error('Failed to apply default heightmap', err));
        },
        undefined,
        (err) => {
          console.error('Failed to load default heightmap', err);
        }
      );
    })();

    // Static camera: no keyboard/mouse movement

    async function createTextureFromFile(file) {
      try {
        const bitmap = await createImageBitmap(file);
        const texture = new THREE.Texture(bitmap);
        texture.needsUpdate = true;
        return texture;
      } catch (err) {
        const dataUrl = await new Promise((resolve, reject) => {
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result);
          fr.onerror = reject;
          fr.readAsDataURL(file);
        });
        const img = await new Promise((resolve, reject) => {
          const i = new Image();
          i.decoding = 'async';
          i.onload = () => resolve(i);
          i.onerror = (e) => reject(e);
          i.src = dataUrl;
        });
        const texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        return texture;
      }
    }

    let currentHeightmapTexture = null;
    let heightmapCanvas = null;
    let heightmapCtx = null;
    let heightmapWidth = 0;
    let heightmapHeight = 0;

    // Sample terrain height at a world XZ position
    function sampleTerrainHeight(worldX, worldZ) {
      if (!heightmapCtx || !heightmapWidth || !heightmapHeight) {
        return null; // No heightmap loaded yet
      }
      
      const tileSize = state.tileSize;
      
      // Account for scroll offset - the terrain moves, so we need to sample
      // relative to the scrolling position
      const relX = worldX + scrollOffset.x;
      const relZ = worldZ + scrollOffset.y;
      
      // Convert to UV coordinates within [0,1] - the texture repeats per tile
      // Add 0.5 to center the sampling (geometry goes from -tileSize/2 to +tileSize/2)
      let u = (((relX / tileSize) + 0.5) % 1 + 1) % 1;
      let v = (((relZ / tileSize) + 0.5) % 1 + 1) % 1;
      // Flip V because PlaneGeometry rotation may invert it
      v = 1.0 - v;
      
      // Convert UV to pixel coordinates
      const px = Math.floor(u * heightmapWidth);
      const py = Math.floor(v * heightmapHeight);
      
      // Clamp to valid range
      const clampedPx = Math.max(0, Math.min(heightmapWidth - 1, px));
      const clampedPy = Math.max(0, Math.min(heightmapHeight - 1, py));
      
      // Sample the pixel
      const pixelData = heightmapCtx.getImageData(clampedPx, clampedPy, 1, 1).data;
      
      // Calculate height using same formula as shader: (r+g+b)/3 * scale + bias
      const r = pixelData[0] / 255;
      const g = pixelData[1] / 255;
      const b = pixelData[2] / 255;
      const h = (r + g + b) / 3;
      
      const scale = pointMaterial.uniforms.uScale.value;
      const bias = pointMaterial.uniforms.uBias.value;
      
      return h * scale + bias;
    }

    async function applyHeightmapTexture(texture) {
      if (currentHeightmapTexture) {
        currentHeightmapTexture.dispose();
      }
      currentHeightmapTexture = texture;
      texture.colorSpace = THREE.NoColorSpace; // treat as data
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      // NPOT safety: use clamp + no mipmaps; POT can repeat+mips
      const img = texture.image;
      const isPOT = img && ( (img.width & (img.width - 1)) === 0 ) && ( (img.height & (img.height - 1)) === 0 );
      if (isPOT) {
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.generateMipmaps = true;
        texture.minFilter = THREE.LinearMipmapLinearFilter;
      } else {
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.generateMipmaps = false;
        texture.minFilter = THREE.LinearFilter;
      }
      texture.magFilter = THREE.LinearFilter;
      texture.needsUpdate = true;

      pointMaterial.uniforms.uMap.value = texture;
      pointMaterial.uniforms.uBias.value = -pointMaterial.uniforms.uScale.value * 0.5;
      pointMaterial.needsUpdate = true;
      rebuildTiling();
      
      // Create canvas for CPU-side heightmap sampling
      const texImg = texture.image;
      if (texImg) {
        heightmapWidth = texImg.width || texImg.naturalWidth || 512;
        heightmapHeight = texImg.height || texImg.naturalHeight || 512;
        heightmapCanvas = document.createElement('canvas');
        heightmapCanvas.width = heightmapWidth;
        heightmapCanvas.height = heightmapHeight;
        heightmapCtx = heightmapCanvas.getContext('2d', { willReadFrequently: true });
        heightmapCtx.drawImage(texImg, 0, 0, heightmapWidth, heightmapHeight);
      }
    }

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      try {
        const texture = await createTextureFromFile(file);
        await applyHeightmapTexture(texture);
        console.log('Heightmap loaded:', file.name);
      } catch (err) {
        console.error('Failed to load heightmap texture', err);
      }
    });

    function handleDropFile(file) {
      if (!file || !file.type.startsWith('image/')) return;
      createTextureFromFile(file)
        .then(applyHeightmapTexture)
        .catch((err) => console.error('Failed to load dropped heightmap', err));
    }

    renderer.domElement.addEventListener('dragover', (e) => {
      e.preventDefault();
      renderer.domElement.classList.add('drag-over');
    });

    renderer.domElement.addEventListener('dragleave', () => {
      renderer.domElement.classList.remove('drag-over');
    });

    renderer.domElement.addEventListener('drop', (e) => {
      e.preventDefault();
      renderer.domElement.classList.remove('drag-over');
      const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) {
        handleDropFile(file);
      }
    });

    // Resize handling
    window.addEventListener('resize', () => {
      const width = canvasContainer.clientWidth;
      const height = canvasContainer.clientHeight;
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    });

    // Animate
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      pointMaterial.uniforms.uTime.value = performance.now() * 0.001;
      // Update hover center from mouse ray on ground plane
      // reuse a simple ray each frame based on last mouse NDC
      if (!window.__raycaster) window.__raycaster = new THREE.Raycaster();
      if (!window.__mouseNdc) window.__mouseNdc = new THREE.Vector2(-2, -2);
      const ray = window.__raycaster;
      ray.setFromCamera(window.__mouseNdc, camera);
      const hit = new THREE.Vector3();
      const ground = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
      if (ray.ray.intersectPlane(ground, hit)) {
        pointMaterial.uniforms.uHoverCenter.value.set(hit.x, hit.z);
      } else {
        pointMaterial.uniforms.uHoverCenter.value.set(9999.0, 9999.0);
      }
      if (params.animateScroll && tilesPoints && tilesPoints.length) {
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        if (forward.lengthSq() < 1e-6) forward.set(0, 0, -1);
        forward.normalize();
        const step = state.scrollSpeed * delta;
        scrollOffset.x += forward.x * step;
        scrollOffset.y += forward.z * step;
        updateTileMatrices();
      }
      // Update airplane
      updateAirplane(delta);
      // Update airplane hover position for shader
      if (airplaneGroup && airplaneState.enabled) {
        pointMaterial.uniforms.uAirplanePos.value.copy(airplaneGroup.position);
        // Update mask center to follow airplane in chase-style modes
        const isChaseStyle = params.cameraMode === 'chase' || params.cameraMode === 'topdown' || params.cameraMode === 'isometric';
        if (isChaseStyle) {
          pointMaterial.uniforms.uMaskCenter.value.set(airplaneState.worldPos.x, airplaneState.worldPos.z);
        }
      } else {
        pointMaterial.uniforms.uAirplanePos.value.set(9999, 9999, 9999);
      }
      
      // Update radar pulse
      if (radarState.active) {
        const now = performance.now() * 0.001;
        const elapsed = now - radarState.startTime;
        const totalDuration = radarState.expandDuration + radarState.persistDuration + radarState.fadeDuration;
        
        // Update time uniform for rain animation
        pointMaterial.uniforms.uRadarTime.value = elapsed;
        
        let currentRadius = 0;
        let currentFade = 1.0;
        
        if (elapsed < radarState.expandDuration) {
          // Expanding phase
          const expandProgress = elapsed / radarState.expandDuration;
          currentRadius = expandProgress * radarState.maxRadius;
          currentFade = 1.0;
          pointMaterial.uniforms.uRadarRadius.value = currentRadius;
          pointMaterial.uniforms.uRadarFade.value = currentFade;
        } else if (elapsed < radarState.expandDuration + radarState.persistDuration) {
          // Persist phase - fully expanded, holding
          currentRadius = radarState.maxRadius;
          currentFade = 1.0;
          pointMaterial.uniforms.uRadarRadius.value = currentRadius;
          pointMaterial.uniforms.uRadarFade.value = currentFade;
        } else if (elapsed < totalDuration) {
          // Fade out phase
          const fadeProgress = (elapsed - radarState.expandDuration - radarState.persistDuration) / radarState.fadeDuration;
          currentRadius = radarState.maxRadius;
          currentFade = 1.0 - fadeProgress;
          pointMaterial.uniforms.uRadarRadius.value = currentRadius;
          pointMaterial.uniforms.uRadarFade.value = currentFade;
        } else {
          // Done
          radarState.active = false;
          pointMaterial.uniforms.uRadarActive.value = 0.0;
          pointMaterial.uniforms.uRadarFade.value = 0.0;
          if (visualRing) visualRing.visible = false;
        }
        
        // Update visual ring - keep it positioned at radar origin
        if (radarState.active && visualRing) {
          const origin = pointMaterial.uniforms.uRadarOrigin.value;
          visualRing.position.set(origin.x, origin.y, origin.z);
          updateVisualRing(currentRadius, currentFade);
        }
        
        // Update rain particle shape uniforms in real-time
        pointMaterial.uniforms.uRainParticleWidth.value = radarState.rainParticleWidth;
        pointMaterial.uniforms.uRainParticleHeight.value = radarState.rainParticleHeight;
        pointMaterial.uniforms.uRainParticleScale.value = radarState.rainParticleScale;
      }
      
      // Camera mode logic with orbit support
      // Use stable airplane position (worldPos) to avoid shake affecting camera
      if (params.cameraMode === 'chase' && airplaneGroup && airplaneState.enabled) {
        // Chase cam: positioned behind the airplane with orbit
        const chaseDist = params.chaseCamDistance;
        const chaseHeight = params.chaseCamHeight;
        
        // Use stable airplane position
        const stablePos = airplaneState.worldPos;
        
        // Apply orbit azimuth to position camera around airplane
        const orbitX = Math.sin(cameraOrbit.azimuth) * chaseDist;
        const orbitZ = Math.cos(cameraOrbit.azimuth) * chaseDist;
        // Apply elevation to height
        const elevationOffset = cameraOrbit.elevation * chaseDist;
        
        const targetCamPos = new THREE.Vector3(
          stablePos.x + orbitX,
          stablePos.y + chaseHeight + elevationOffset,
          stablePos.z + orbitZ
        );
        
        // Smooth camera movement
        camera.position.lerp(targetCamPos, Math.min(1, 8 * delta));
        
        // Look at the stable airplane position
        camera.lookAt(stablePos);
      } else if (params.cameraMode === 'topdown' && airplaneGroup && airplaneState.enabled) {
        // Top-down cam: above the airplane with orbit rotation
        const topHeight = params.topCamHeight;
        
        // Use stable airplane position (worldPos) instead of shake-affected position
        const stablePos = airplaneState.worldPos;
        
        // Apply orbit for slight offset from directly above
        const orbitOffset = cameraOrbit.elevation * topHeight * 0.5;
        const orbitX = Math.sin(cameraOrbit.azimuth) * orbitOffset;
        const orbitZ = Math.cos(cameraOrbit.azimuth) * orbitOffset;
        
        const targetCamPos = new THREE.Vector3(
          stablePos.x + orbitX,
          stablePos.y + topHeight,
          stablePos.z + orbitZ
        );
        
        // Smooth camera movement
        camera.position.lerp(targetCamPos, Math.min(1, 8 * delta));
        
        // For top-down, set rotation directly instead of lookAt to avoid gimbal lock
        // Rotate to look straight down (-Y), with Z as forward direction
        camera.rotation.set(-Math.PI / 2, 0, -cameraOrbit.azimuth);
      } else if (params.cameraMode === 'isometric' && airplaneGroup && airplaneState.enabled) {
        // Isometric cam: view from behind and above with orbit
        const isoDist = params.isoCamDistance;
        const isoHeight = params.isoCamHeight;
        
        // Use stable airplane position
        const stablePos = airplaneState.worldPos;
        
        // Apply orbit azimuth to position camera around airplane
        const orbitX = Math.sin(cameraOrbit.azimuth) * isoDist;
        const orbitZ = Math.cos(cameraOrbit.azimuth) * isoDist;
        // Apply elevation to height
        const elevationOffset = cameraOrbit.elevation * isoDist;
        
        const targetCamPos = new THREE.Vector3(
          stablePos.x + orbitX,
          stablePos.y + isoHeight + elevationOffset,
          stablePos.z + orbitZ
        );
        
        // Smooth camera movement
        camera.position.lerp(targetCamPos, Math.min(1, 8 * delta));
        
        // Look at the stable airplane position
        camera.lookAt(stablePos);
      }
      
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>


